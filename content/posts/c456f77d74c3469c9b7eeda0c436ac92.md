---
title: Android 15 特权应用默认授予全部权限功能说明
slug: c456f77d74c3469c9b7eeda0c436ac92
tags:
  - android
date: 2026-01-28T11:11:48.714Z
---

## 一、功能概述

此修改为 Android 15 系统中的 `PermissionManagerService` 新增了一个功能：**为指定的特权应用（Privileged Apps）在安装后自动授予所有请求的权限**，包括运行时权限和部分特殊权限（如 `SYSTEM_ALERT_WINDOW`、`REQUEST_INSTALL_PACKAGES`）。

该功能通过系统属性 `ro.kte.privileged_apps.enabled` 控制是否启用，特权应用列表可从配置文件 `/etc/privileged_apps.conf` 或系统属性 `persist.sys.privileged_apps` 中加载。

## 二、修改文件

system/frameworks/base/services/core/java/com/android/server/pm/permission/PermissionManagerService.java

## 三、核心改动说明

### 1. 新增成员变量

- `PRIVILEGED_APPS_CONFIG_FILE`：配置文件路径

- `mPrivilegedPackages`：特权应用包名集合

- `PRIVILEGED_APPS_ENABLED`：功能开关（读取系统属性）

- `mHandler`：用于延迟任务处理

- 多个标志位用于跟踪状态（如是否已注册广播、是否已加载配置等）

### 2. 新增关键方法

- `loadPrivilegedAppsConfig()`：从配置文件和系统属性加载特权应用列表

- `isPrivilegedApp()`：判断应用是否为特权应用

- `grantAllPermissionsToPackage()`：为指定包名授予所有权限

- `grantSpecialPermission()`：授予特殊权限（通过 AppOpsManager）

- `registerBroadcastReceivers()`：注册广播监听应用安装和系统启动

- `addPrivilegedApp()` / `removePrivilegedApp()`：动态增删特权应用

### 3. 权限授予机制

- 当特权应用安装或更新时，自动授予所有运行时权限

- 系统启动完成后，遍历所有用户下的已安装应用，为特权应用授予权限

- 支持重试机制，对首次授权失败的部分权限进行延迟重试

- 设置权限标志 `FLAG_PERMISSION_GRANTED_BY_DEFAULT`，允许用户后续修改

### 4. 动态配置支持

- 可通过系统属性 `persist.sys.privileged_apps` 动态添加特权应用

- 格式为逗号分隔的包名列表

- 修改后调用 `reloadPrivilegedAppsConfig()` 生效

### 5. 集成到系统生命周期

- 在 `onSystemReady()` 中注册广播并触发初始授权

- 在 `onPackageInstalled()` 中检测新安装的特权应用并立即授权

- 在 `dump()` 方法中输出特权应用相关状态信息，便于调试

## 四、使用方法

### 1. 启用功能

设置系统属性：

```bash
setprop ro.kte.privileged_apps.enabled true
```

### 2. 配置特权应用

- **静态配置**：编辑 `/etc/privileged_apps.conf`，每行一个包名

- **动态配置**：设置 `persist.sys.privileged_apps` 属性，如：

```bash
setprop persist.sys.privileged_apps com.example.app1,com.example.app2
```

### 3. 动态增删应用（通过 API）

```java
PermissionManagerService service = ...;  
service.addPrivilegedApp("com.example.app3");  
service.removePrivilegedApp("com.example.app1");
```

### 4. 查看状态

可通过 `dumpsys` 查看特权应用配置状态：

```bash
dumpsys permission
```

## 五、注意事项

- 仅授予应用已声明的权限，未声明的权限不会主动添加

- 仅处理运行时权限（`isRuntime()`），安装时权限不受影响

- 授权后会设置“默认授予”标志，用户仍可在设置中撤销

- 支持多用户环境，每个用户独立授权

- 重试机制可能因应用未完全启动而失败，建议确保应用已正常运行

## 六、完整修改内容

```diff
--- a/system/frameworks/base/services/core/java/com/android/server/pm/permission/PermissionManagerService.java
+++ b/system/frameworks/base/services/core/java/com/android/server/pm/permission/PermissionManagerService.java
@@ -45,9 +45,13 @@ import android.app.IActivityManager;
 import android.companion.virtual.VirtualDeviceManager;
 import android.content.AttributionSource;
 import android.content.AttributionSourceState;
+import android.content.BroadcastReceiver;
 import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
 import android.content.PermissionChecker;
 import android.content.pm.FeatureInfo;
+import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.content.pm.PackageManagerInternal;
 import android.content.pm.ParceledListSlice;
@@ -56,10 +60,13 @@ import android.content.pm.PermissionInfo;
 import android.content.pm.permission.SplitPermissionInfoParcelable;
 import android.health.connect.HealthConnectManager;
 import android.os.Binder;
+import android.os.Handler;
 import android.os.IBinder;
+import android.os.Looper;
 import android.os.Process;
 import android.os.RemoteException;
 import android.os.ServiceManager;
+import android.os.SystemProperties;
 import android.os.UserHandle;
 import android.permission.IOnPermissionsChangeListener;
 import android.permission.IPermissionChecker;
@@ -69,7 +76,9 @@ import android.permission.PermissionManager;
 import android.permission.PermissionManager.PermissionState;
 import android.permission.PermissionManagerInternal;
 import android.service.voice.VoiceInteractionManagerInternal;
+import android.text.TextUtils;
 import android.util.ArrayMap;
+import android.util.ArraySet;
 import android.util.Slog;
 import android.util.SparseArray;
 
@@ -87,6 +96,12 @@ import com.android.server.pm.pkg.PackageState;
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
 import java.util.List;
 import java.util.Map;
 import java.util.NoSuchElementException;
@@ -97,6 +112,10 @@ import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import android.app.AppOpsManager;
+import static android.app.AppOpsManager.OP_SYSTEM_ALERT_WINDOW;
+import static android.app.AppOpsManager.OP_REQUEST_INSTALL_PACKAGES;
+
 /**
  * Manages all permissions and handles permissions related tasks.
  */
@@ -138,6 +157,34 @@ public class PermissionManagerService extends IPermissionManager.Stub {
     @Nullable
     private VirtualDeviceManagerInternal mVirtualDeviceManagerInternal;
 
+    /** Handler for delayed operations */
+    private final Handler mHandler = new Handler(Looper.getMainLooper());
+
+    /** 特权应用配置文件路径 */
+    private static final String PRIVILEGED_APPS_CONFIG_FILE = "/etc/privileged_apps.conf";
+
+    /** 特权应用包名集合 - 这些应用的所有权限将自动授予 */
+    private final ArraySet<String> mPrivilegedPackages = new ArraySet<>();
+
+    /** 从配置文件加载的特权应用包名 */
+    private final ArraySet<String> mConfigPrivilegedPackages = new ArraySet<>();
+
+    /** 从系统属性加载的特权应用包名 */
+    private final ArraySet<String> mDynamicPrivilegedPackages = new ArraySet<>();
+
+    /** 是否启用特权应用功能的标志 */
+    private static final String PRIVILEGED_APPS_PROP = "ro.kte.privileged_apps.enabled";
+    private static final boolean PRIVILEGED_APPS_ENABLED = SystemProperties.getBoolean(PRIVILEGED_APPS_PROP, false);
+
+    /** 标记是否已经注册了广播接收器 */
+    private boolean mBroadcastReceiversRegistered = false;
+
+    /** 标记是否已经授予了初始权限 */
+    private boolean mInitialPermissionsGranted = false;
+
+    /** 标记是否已经加载了配置文件 */
+    private boolean mConfigLoaded = false;
+
     PermissionManagerService(@NonNull Context context,
             @NonNull ArrayMap<String, FeatureInfo> availableFeatures) {
         // The package info cache is the cache for package and permission information.
@@ -166,6 +213,13 @@ public class PermissionManagerService extends IPermissionManager.Stub {
             mPermissionManagerServiceImpl = new PermissionManagerServiceImpl(context,
                     availableFeatures);
         }
+	
+	//zhangkai 2026-1-14, grants deafult permissions for privileged apps.
+	if (PRIVILEGED_APPS_ENABLED) {
+        // 加载特权应用配置
+        loadPrivilegedAppsConfig();
+	}
+	//zhangkai 2026-1-14, grants deafult permissions for privileged apps.
     }
 
     /**
@@ -221,6 +275,429 @@ public class PermissionManagerService extends IPermissionManager.Stub {
         }
     }
 
+    //zhangkai 2026-1-14, grants deafult permissions for privileged apps.
+    /**
+     * 从配置文件和系统属性加载特权应用列表
+     */
+    private void loadPrivilegedAppsConfig() {
+        if (mConfigLoaded) {
+            return;
+        }
+
+        // 清空集合
+        mPrivilegedPackages.clear();
+        mConfigPrivilegedPackages.clear();
+        mDynamicPrivilegedPackages.clear();
+
+        // 从配置文件加载
+        loadPrivilegedAppsFromConfigFile();
+
+        // 从系统属性加载
+        loadPrivilegedAppsFromSystemProperties();
+
+        // 合并所有特权应用包名
+        mPrivilegedPackages.addAll(mConfigPrivilegedPackages);
+        mPrivilegedPackages.addAll(mDynamicPrivilegedPackages);
+
+        mConfigLoaded = true;
+
+        Slog.i(LOG_TAG, "Loaded " + mPrivilegedPackages.size() +
+               " privileged apps (" + mConfigPrivilegedPackages.size() +
+               " from config, " + mDynamicPrivilegedPackages.size() + " from system properties)");
+    }
+
+    /**
+     * 重新加载特权应用配置
+     */
+    public void reloadPrivilegedAppsConfig() {
+        mConfigLoaded = false;
+        loadPrivilegedAppsConfig();
+    }
+
+    /**
+     * 检查是否为特权应用
+     */
+    private boolean isPrivilegedApp(String packageName) {
+        // 检查静态配置
+        if (mPrivilegedPackages.contains(packageName)) {
+            return true;
+        }
+
+        // 检查动态配置（系统属性）
+        String dynamicConfig = SystemProperties.get("persist.sys.privileged_apps", "");
+        if (!TextUtils.isEmpty(dynamicConfig)) {
+            String[] packages = dynamicConfig.split(",");
+            for (String pkg : packages) {
+                if (pkg.trim().equals(packageName)) {
+                    return true;
+                }
+            }
+        }
+        
+        return false;
+    }
+
+	//zhangkai 2026-1-14, grants deafult permissions for privileged apps.
+    /** 标记特权应用的初始权限授予是否完成 */
+    private final Map<String, Boolean> mInitialPermissionsGrantedMap = new ConcurrentHashMap<>();
+	//zhangkai 2026-1-14, grants deafult permissions for privileged apps.
+
+    /**
+     * 为特权应用授予所有权限
+     */
+    private void grantAllPermissionsToPackage(String packageName, int userId) {
+        if (!PRIVILEGED_APPS_ENABLED) {
+            return;
+        }
+
+        final long token = Binder.clearCallingIdentity();
+        try {
+			//zhangkai 2026-1-14, grants deafult permissions for privileged apps.
+            // 检查是否已经授予过初始权限
+            String key = packageName + "|" + userId;
+            if (mInitialPermissionsGrantedMap.getOrDefault(key, false)) {
+                Slog.d(LOG_TAG, "Initial permissions already granted for " + packageName + " user " + userId);
+                return;
+            }
+			//zhangkai 2026-1-14, grants deafult permissions for privileged apps.
+
+            // 获取应用信息
+            PackageManager pm = mContext.getPackageManager();
+            PackageInfo pkgInfo = pm.getPackageInfoAsUser(packageName,
+                PackageManager.GET_PERMISSIONS | PackageManager.MATCH_UNINSTALLED_PACKAGES,
+                userId);
+
+            if (pkgInfo == null) {
+                Slog.w(LOG_TAG, "No package info for " + packageName);
+                return;
+            }
+
+            Slog.i(LOG_TAG, "Granting permissions to privileged app: " + packageName + " for user " + userId);
+
+            // 授予特殊权限
+            grantSpecialPermission(packageName, userId, OP_SYSTEM_ALERT_WINDOW, "SYSTEM_ALERT_WINDOW");
+            grantSpecialPermission(packageName, userId, OP_REQUEST_INSTALL_PACKAGES, "REQUEST_INSTALL_PACKAGES");
+
+            if (pkgInfo.requestedPermissions == null || pkgInfo.requestedPermissions.length == 0) {
+                Slog.w(LOG_TAG, "No requested permissions for " + packageName);
+                return;
+            }
+
+            boolean hasGrantedAny = false;
+            List<String> failedPermissions = new ArrayList<>();
+
+            // 遍历应用请求的所有权限
+            for (String permission : pkgInfo.requestedPermissions) {
+                try {
+                    // 检查权限是否存在
+                    PermissionInfo permInfo = getPermissionInfo(permission, packageName, 0);
+                    if (permInfo == null) {
+                        Slog.w(LOG_TAG, "Permission not found: " + permission);
+                        continue;
+                    }
+
+                    // 只处理运行时权限
+                    if (!permInfo.isRuntime()) {
+                        Slog.d(LOG_TAG, "Skipping non-runtime permission: " + permission);
+                        continue;
+                    }
+
+                    // 检查权限是否已经被授予
+                    int permissionResult = mPermissionManagerServiceImpl.checkPermission(
+                        packageName,
+                        permission,
+                        VirtualDeviceManager.PERSISTENT_DEVICE_ID_DEFAULT,
+                        userId);
+
+                    if (permissionResult != PackageManager.PERMISSION_GRANTED) {
+                        // 授予权限
+                        Slog.i(LOG_TAG, "Granting permission: " + permission + " to " + packageName);
+                        mPermissionManagerServiceImpl.grantRuntimePermission(packageName, permission,
+                            VirtualDeviceManager.PERSISTENT_DEVICE_ID_DEFAULT, userId);
+                    }
+
+                    // 设置权限标志为默认授予（允许用户修改）
+                    mPermissionManagerServiceImpl.updatePermissionFlags(packageName, permission,
+                        PackageManager.FLAG_PERMISSION_GRANTED_BY_DEFAULT,
+                        PackageManager.FLAG_PERMISSION_GRANTED_BY_DEFAULT,
+                        false,
+                        VirtualDeviceManager.PERSISTENT_DEVICE_ID_DEFAULT,
+                        userId);
+
+                    hasGrantedAny = true;
+                    Slog.i(LOG_TAG, "Successfully granted permission " + permission + " to " + packageName);
+
+                } catch (Exception e) {
+                    Slog.w(LOG_TAG, "Could not grant permission " + permission +
+                           " to " + packageName + ": " + e.getMessage());
+                    failedPermissions.add(permission);
+                }
+            }
+
+            if (!failedPermissions.isEmpty()) {
+                Slog.w(LOG_TAG, "Failed to grant " + failedPermissions.size() +
+                       " permissions to " + packageName + ": " + failedPermissions);
+
+                // 延迟重试失败的权限
+                if (hasGrantedAny) {
+                    mHandler.postDelayed(() -> {
+                        retryFailedPermissions(packageName, userId, failedPermissions);
+                    }, 5000);
+                }
+            }
+
+			//zhangkai 2026-1-14, grants deafult permissions for privileged apps.
+            // 标记初始权限已授予
+            mInitialPermissionsGrantedMap.put(key, true);
+			//zhangkai 2026-1-14, grants deafult permissions for privileged apps.
+
+        } catch (Exception e) {
+            Slog.e(LOG_TAG, "Error granting permissions to " + packageName + " for user " + userId, e);
+        } finally {
+            Binder.restoreCallingIdentity(token);
+        }
+    }
+
+    /**
+     * 重试失败的权限授予
+     */
+    private void retryFailedPermissions(String packageName, int userId, List<String> permissions) {
+        for (String permission : permissions) {
+            try {
+                mPermissionManagerServiceImpl.grantRuntimePermission(packageName, permission,
+                    VirtualDeviceManager.PERSISTENT_DEVICE_ID_DEFAULT, userId);
+
+                mPermissionManagerServiceImpl.updatePermissionFlags(packageName, permission,
+                    PackageManager.FLAG_PERMISSION_GRANTED_BY_DEFAULT,
+                    PackageManager.FLAG_PERMISSION_GRANTED_BY_DEFAULT,
+                    false,
+                    VirtualDeviceManager.PERSISTENT_DEVICE_ID_DEFAULT,
+                    userId);
+
+                Slog.i(LOG_TAG, "Retry succeeded for permission " + permission + " to " + packageName);
+            } catch (Exception e) {
+                Slog.e(LOG_TAG, "Retry failed for permission " + permission + " to " + packageName, e);
+            }
+        }
+    }
+
+    /**
+     * 授予特殊权限（通过AppOpsManager）
+     */
+    private void grantSpecialPermission(String packageName, int userId, int opCode, String opName) {
+        try {
+            // 获取应用UID
+            PackageManager pm = mContext.getPackageManager();
+            PackageInfo pkgInfo = pm.getPackageInfoAsUser(packageName,
+                PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);
+
+            if (pkgInfo == null) {
+                return;
+            }
+
+            int uid = pkgInfo.applicationInfo.uid;
+
+            // 设置AppOps为允许
+            mAppOpsManager.setMode(opCode, uid, packageName, AppOpsManager.MODE_ALLOWED);
+
+            Slog.i(LOG_TAG, "Granted special permission " + opName + " to " + packageName + " (UID: " + uid + ")");
+
+        } catch (Exception e) {
+            Slog.w(LOG_TAG, "Could not grant special permission " + opName + " to " + packageName, e);
+        }
+    }
+
+    /**
+     * 为所有特权应用授予权限
+     */
+    private void grantPermissionsToAllPrivilegedApps() {
+        if (!PRIVILEGED_APPS_ENABLED || mInitialPermissionsGranted) {
+            return;
+        }
+        
+        Slog.i(LOG_TAG, "Starting to grant permissions to all privileged apps");
+        
+        int[] userIds = getAllUserIds();
+        PackageManager pm = mContext.getPackageManager();
+        
+        for (int userId : userIds) {
+            try {
+                List<PackageInfo> packages = pm.getInstalledPackagesAsUser(
+                    PackageManager.GET_PERMISSIONS | PackageManager.MATCH_UNINSTALLED_PACKAGES, 
+                    userId);
+                
+                for (PackageInfo pkgInfo : packages) {
+                    if (isPrivilegedApp(pkgInfo.packageName)) {
+                        Slog.i(LOG_TAG, "Found privileged app: " + pkgInfo.packageName + " for user " + userId);
+                        grantAllPermissionsToPackage(pkgInfo.packageName, userId);
+                    }
+                }
+            } catch (Exception e) {
+                Slog.e(LOG_TAG, "Error processing user " + userId, e);
+            }
+        }
+        
+        mInitialPermissionsGranted = true;
+        Slog.i(LOG_TAG, "Finished granting permissions to all privileged apps");
+    }
+
+    /**
+     * 注册广播接收器
+     */
+    private void registerBroadcastReceivers() {
+        if (mBroadcastReceiversRegistered) {
+            return;
+        }
+        
+        try {
+            BroadcastReceiver receiver = new BroadcastReceiver() {
+                @Override
+                public void onReceive(Context context, Intent intent) {
+                    String action = intent.getAction();
+                    if (Intent.ACTION_PACKAGE_ADDED.equals(action) ||
+                        Intent.ACTION_PACKAGE_REPLACED.equals(action)) {
+                        String packageName = intent.getData().getSchemeSpecificPart();
+                        int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, UserHandle.USER_SYSTEM);
+                        
+                        if (isPrivilegedApp(packageName)) {
+                            Slog.i(LOG_TAG, "Package added/replaced: " + packageName + 
+                                   ", granting permissions for user " + userId);
+                            mHandler.post(() -> {
+                                grantAllPermissionsToPackage(packageName, userId);
+                            });
+                        }
+                    } else if (Intent.ACTION_BOOT_COMPLETED.equals(action)) {
+                        // 系统启动完成后，再次检查并授予权限
+                        mHandler.postDelayed(() -> {
+                            grantPermissionsToAllPrivilegedApps();
+                        }, 10000); // 延迟10秒确保系统完全启动
+                    }
+                }
+            };
+            
+            IntentFilter filter = new IntentFilter();
+            filter.addAction(Intent.ACTION_PACKAGE_ADDED);
+            filter.addAction(Intent.ACTION_PACKAGE_REPLACED);
+            filter.addDataScheme("package");
+            filter.addAction(Intent.ACTION_BOOT_COMPLETED);
+            
+            mContext.registerReceiver(receiver, filter);
+            mBroadcastReceiversRegistered = true;
+            Slog.i(LOG_TAG, "Privileged app broadcast receivers registered");
+        } catch (Exception e) {
+            Slog.e(LOG_TAG, "Failed to register broadcast receivers", e);
+        }
+    }
+
+    /**
+     * 添加特权应用
+     */
+    public void addPrivilegedApp(String packageName) {
+        // 添加到系统属性
+        addPrivilegedAppToSystemProperties(packageName);
+
+        // 重新加载配置
+        reloadPrivilegedAppsConfig();
+        
+        Slog.i(LOG_TAG, "Added " + packageName + " to privileged apps");
+    }
+
+    /**
+     * 将特权应用添加到系统属性
+     */
+    private void addPrivilegedAppToSystemProperties(String packageName) {
+        if (TextUtils.isEmpty(packageName)) {
+            return;
+        }
+
+        String current = getDynamicPrivilegedAppsProperty();
+         if (TextUtils.isEmpty(current)) {
+             SystemProperties.set("persist.sys.privileged_apps", packageName);
+         } else if (!current.contains(packageName)) {
+             SystemProperties.set("persist.sys.privileged_apps", current + "," + packageName);
+         }
+     }
+
+    /**
+     * 从系统属性加载特权应用
+     */
+    private void loadPrivilegedAppsFromSystemProperties() {
+        String dynamicConfig = getDynamicPrivilegedAppsProperty();
+        if (!TextUtils.isEmpty(dynamicConfig)) {
+            String[] packages = dynamicConfig.split(",");
+            for (String pkg : packages) {
+                String trimmedPkg = pkg.trim();
+                if (!TextUtils.isEmpty(trimmedPkg)) {
+                    mDynamicPrivilegedPackages.add(trimmedPkg);
+                }
+            }
+        }
+    }
+
+    /**
+     * 从配置文件加载特权应用
+     */
+    private void loadPrivilegedAppsFromConfigFile() {
+        File configFile = new File(PRIVILEGED_APPS_CONFIG_FILE);
+        if (!configFile.exists() || !configFile.canRead()) {
+            Slog.w(LOG_TAG, "Privileged apps config file not found or not readable: " +
+                   PRIVILEGED_APPS_CONFIG_FILE);
+            return;
+        }
+
+        try (BufferedReader reader = new BufferedReader(new FileReader(configFile))) {
+            String line;
+            int lineNumber = 0;
+            while ((line = reader.readLine()) != null) {
+                lineNumber++;
+                String trimmedLine = line.trim();
+
+                // 跳过空行和注释行
+                if (TextUtils.isEmpty(trimmedLine) || trimmedLine.startsWith("#")) {
+                    continue;
+                }
+
+                // 添加到配置集合
+                mConfigPrivilegedPackages.add(trimmedLine);
+                Slog.d(LOG_TAG, "Loaded privileged app from config line " + lineNumber + ": " + trimmedLine);
+            }
+
+            Slog.i(LOG_TAG, "Loaded " + mConfigPrivilegedPackages.size() +
+                   " privileged apps from config file: " + PRIVILEGED_APPS_CONFIG_FILE);
+
+        } catch (Exception e) {
+            Slog.e(LOG_TAG, "Error reading privileged apps config file: " +
+                   PRIVILEGED_APPS_CONFIG_FILE, e);
+        }
+    }
+
+    /**
+     * 移除特权应用
+     */
+    public void removePrivilegedApp(String packageName) {
+        // 从系统属性中移除
+        String current = SystemProperties.get("persist.sys.privileged_apps", "");
+        if (!TextUtils.isEmpty(current)) {
+            String[] packages = current.split(",");
+            StringBuilder newList = new StringBuilder();
+            for (String pkg : packages) {
+                if (!pkg.trim().equals(packageName)) {
+                    if (newList.length() > 0) {
+                        newList.append(",");
+                    }
+                    newList.append(pkg);
+                }
+            }
+            SystemProperties.set("persist.sys.privileged_apps", newList.toString());
+        }
+        
+        // 重新加载配置
+        reloadPrivilegedAppsConfig();
+        
+        Slog.i(LOG_TAG, "Removed " + packageName + " from privileged apps");
+    }
+    //zhangkai 2026-1-14, grants deafult permissions for privileged apps.
+
     @Override
     @PackageManager.PermissionResult
     public int checkPermission(String packageName, String permissionName, String persistentDeviceId,
@@ -252,7 +729,7 @@ public class PermissionManagerService extends IPermissionManager.Stub {
         }
 
         String persistentDeviceId = getPersistentDeviceId(deviceId);
-
+        
         final CheckPermissionDelegate checkPermissionDelegate;
         synchronized (mLock) {
             checkPermissionDelegate = mCheckPermissionDelegate;
@@ -732,6 +1209,17 @@ public class PermissionManagerService extends IPermissionManager.Stub {
                     || rawUserId == UserHandle.USER_ALL, "userId");
 
             mPermissionManagerServiceImpl.onPackageInstalled(pkg, previousAppId, params, rawUserId);
+            
+	    //zhangkai 2026-1-14, grants deafult permissions for privileged apps.
+            // 如果是特权应用，授予所有权限
+            if (PRIVILEGED_APPS_ENABLED && isPrivilegedApp(pkg.getPackageName())) {
+                Slog.i(LOG_TAG, "Privileged app installed: " + pkg.getPackageName() + ", granting permissions");
+                mHandler.post(() -> {
+                    grantAllPermissionsToPackage(pkg.getPackageName(), rawUserId);
+                });
+            }
+	    //zhangkai 2026-1-14, grants deafult permissions for privileged apps.
+            
             final int[] userIds = rawUserId == UserHandle.USER_ALL ? getAllUserIds()
                     : new int[] { rawUserId };
             for (final int userId : userIds) {
@@ -770,6 +1258,21 @@ public class PermissionManagerService extends IPermissionManager.Stub {
         @Override
         public void onSystemReady() {
             mPermissionManagerServiceImpl.onSystemReady();
+            
+	    //zhangkai 2026-1-14, grants deafult permissions for privileged apps.
+	    if (PRIVILEGED_APPS_ENABLED) {
+            // 系统就绪后，注册广播接收器
+            mHandler.post(() -> {
+                registerBroadcastReceivers();
+            });
+            
+            // 系统就绪后，为所有特权应用授予权限
+            mHandler.postDelayed(() -> {
+                Slog.i(LOG_TAG, "System ready, starting privileged app permission grant");
+                grantPermissionsToAllPrivilegedApps();
+            }, 3000); // 延迟3秒确保系统完全启动
+	    }
+	    //zhangkai 2026-1-14, grants deafult permissions for privileged apps.
         }
 
         @Override
@@ -1742,5 +2245,41 @@ public class PermissionManagerService extends IPermissionManager.Stub {
     protected void dump(@NonNull FileDescriptor fd, @NonNull PrintWriter writer,
             @Nullable String[] args) {
         mPermissionManagerServiceImpl.dump(fd, writer, args);
+
+	//zhangkai 2026-1-14, grants deafult permissions for privileged apps.   
+	if (PRIVILEGED_APPS_ENABLED) {     
+        // 添加特权应用信息
+        writer.println();
+        writer.println("Privileged Apps Configuration:");
+        writer.println("  Feature enabled: " + PRIVILEGED_APPS_ENABLED);
+        writer.println("  System Property (persist.sys.privileged_apps.enabled): " + 
+                      SystemProperties.get(PRIVILEGED_APPS_PROP, "true"));
+        writer.println("  Privileged Apps List (persist.sys.privileged_apps): " + 
+                      getDynamicPrivilegedAppsProperty());
+        writer.println("  Config File: " + PRIVILEGED_APPS_CONFIG_FILE +
+                      " (exists: " + new File(PRIVILEGED_APPS_CONFIG_FILE).exists() + ")");
+        writer.println("  Config Privileged Packages (" + mConfigPrivilegedPackages.size() + "):");
+        for (String pkg : mConfigPrivilegedPackages) {
+            writer.println("    [C] " + pkg);
+        }
+        writer.println("  Dynamic Privileged Packages (" + mDynamicPrivilegedPackages.size() + "):");
+        for (String pkg : mDynamicPrivilegedPackages) {
+            writer.println("    [D] " + pkg);
+        }
+        writer.println("  All Privileged Packages (" + mPrivilegedPackages.size() + "):");
+        for (String pkg : mPrivilegedPackages) {
+            writer.println("    [A] " + pkg);
+        }
+        writer.println("  Config loaded: " + mConfigLoaded);
+        writer.println("  Broadcast receivers registered: " + mBroadcastReceiversRegistered);
+        writer.println("  Initial permissions granted: " + mInitialPermissionsGranted);
+	}
+	//zhangkai 2026-1-14, grants deafult permissions for privileged apps.
+    }
+
+    //zhangkai 2026-1-14, grants deafult permissions for privileged apps.
+    private static String getDynamicPrivilegedAppsProperty() {
+        return SystemProperties.get("persist.sys.privileged_apps", "");
     }
+    //zhangkai 2026-1-14, grants deafult permissions for privileged apps.
 }

```
